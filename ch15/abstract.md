1. 友元类的所有方法都可以访问原始类的私有成员何保护成员
2. 友元函数，友元成员函数(特定的成员函数指定为另一个类的友元)，友元类
3. 友元扩展了类的接口
4. 一个类可以改变另一个类的状态的，此时可以使用友元类
5. 友元类的声明与所在位置无关紧要，可以在任何位置
6. 关系可以一对多，例如一个Remote实例可以访问每一个Tv实例
7. 前置声明，也称前向声明(forward declaration)。在声明之后，定义之前，类Screen是个不完整类型(incomplete type)，即已知Screen是一个类型，但是不知道包含哪些成员。不完全类型只能以有限方式使用。不能定义该类型的对象。不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数。可以通过前置声明配合指针或引用类型声明来减少编译依赖。 C++委托->编译防火墙
8. throw紧随其后的值指出了异常的特征(例如字符串或对象，通常为类类型),throw抛出让catch接，throw语句实际上是跳转，throw后面可以跟一个或多个catch块
9. catch关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个位置执行。
10. throw后退直到找到包含try块的函数，找到该try块后面对应的catch
11. 如果没有try块或者相匹配的catch时，在默认情况下，将会调用abort()函数
12. 通常，引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同的情况下引发的异常。另外，对象可以携带信息，可以根据信息来确定引发的异常
13. C++11建议忽略异常规范，使用noexcept替代throw()，指出函数不会引发异常，知道函数不会引发异常有助于编译器优化代码
14. 栈解退(unwinding the stack),异常机制将负责释放栈中的自动变量
15. 引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。因为如果是引用的话，throw后该变对象已经不存在。
16. 之所以使用引用，是利用基类指针可以指向派生类对象。假设有一组通过继承关联起来的异常类型，则只需要列出一个基类引用，它将与任何派生类对象匹配
17. 如果有一个异常类继承层次结构，应该这样排列catch块:将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面
18. catch(...) 捕获任何异常，通常放在catch块最后面，让显式的异常先匹配















































